/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => InlineOutlinePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  showOutline: true,
  minimalOutline: false,
  hideProperties: true,
  hideScrollbar: false,
  focusMode: false,
  focusDimOpacity: 30
};

// src/main.ts
var OUTLINE_STYLES = `
:root{--outline-right-offset:24px;--outline-max-width:200px;--outline-breakpoint:900px}
.inline-outline{position:fixed;right:var(--outline-right-offset);top:50%;transform:translateY(-50%);z-index:10;display:flex;flex-direction:column;align-items:flex-end;gap:6px;padding:12px 8px;border-radius:6px;background:transparent;max-height:70vh;overflow-y:auto;overflow-x:hidden}
.inline-outline:hover{background:var(--background-primary);box-shadow:0 2px 12px rgba(0,0,0,.1);padding:12px 16px 12px 12px;align-items:flex-start}
.inline-outline-item{display:flex;align-items:center;justify-content:flex-end;cursor:pointer;padding:3px 0;width:100%}
.inline-outline:hover .inline-outline-item{justify-content:flex-start}
.inline-outline-line{height:2px;border-radius:1px;background:var(--text-faint);opacity:.5;flex-shrink:0}
.inline-outline-item:hover .inline-outline-line{background:var(--text-accent);opacity:1}
.inline-outline-item.active .inline-outline-line{background:var(--text-accent);opacity:1;height:3px}
.inline-outline-level-1 .inline-outline-line{width:28px}
.inline-outline-level-2 .inline-outline-line{width:22px}
.inline-outline-level-3 .inline-outline-line{width:16px}
.inline-outline-level-4 .inline-outline-line{width:12px}
.inline-outline-level-5 .inline-outline-line{width:8px}
.inline-outline-level-6 .inline-outline-line{width:6px}
.inline-outline:hover .inline-outline-line{display:none}
.inline-outline-text{font-size:12px;line-height:1.4;color:var(--text-muted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;display:none;max-width:var(--outline-max-width)}
.inline-outline:hover .inline-outline-text{display:block}
.inline-outline-item:hover .inline-outline-text{color:var(--text-normal)}
.inline-outline-item.active .inline-outline-text{color:var(--text-accent);font-weight:500}
.inline-outline:hover .inline-outline-level-1{padding-left:0}
.inline-outline:hover .inline-outline-level-2{padding-left:10px}
.inline-outline:hover .inline-outline-level-3{padding-left:20px}
.inline-outline:hover .inline-outline-level-4{padding-left:30px}
.inline-outline:hover .inline-outline-level-5{padding-left:40px}
.inline-outline:hover .inline-outline-level-6{padding-left:50px}
.inline-outline-level-1 .inline-outline-text{font-weight:600;font-size:13px}
.inline-outline-level-2 .inline-outline-text{font-weight:500}
.inline-outline-empty{display:none}
.inline-outline:hover .inline-outline-empty{display:block;color:var(--text-faint);font-size:11px;white-space:nowrap}
.inline-outline::-webkit-scrollbar{width:4px}
.inline-outline::-webkit-scrollbar-track{background:transparent}
.inline-outline::-webkit-scrollbar-thumb{background:var(--background-modifier-border);border-radius:2px}
@media(max-width:900px){.inline-outline{display:none}}
.theme-dark .inline-outline:hover{background:var(--background-secondary);box-shadow:0 2px 16px rgba(0,0,0,.3)}
.inline-outline.minimal-style{top:120px;transform:none;gap:4px;padding:8px 6px;max-height:50vh}
.inline-outline.minimal-style:hover{padding:8px 12px 8px 8px}
.inline-outline.minimal-style .inline-outline-item{padding:2px 0}
.inline-outline.minimal-style .inline-outline-level-1 .inline-outline-line{width:20px}
.inline-outline.minimal-style .inline-outline-level-2 .inline-outline-line{width:16px}
.inline-outline.minimal-style .inline-outline-level-3 .inline-outline-line{width:12px}
.inline-outline.minimal-style .inline-outline-level-4 .inline-outline-line{width:9px}
.inline-outline.minimal-style .inline-outline-level-5 .inline-outline-line{width:6px}
.inline-outline.minimal-style .inline-outline-level-6 .inline-outline-line{width:4px}
.inline-outline.minimal-style .inline-outline-line{height:1.5px;opacity:.4}
.inline-outline.minimal-style .inline-outline-item.active .inline-outline-line{height:2px}
.inline-outline.minimal-style .inline-outline-text{font-size:11px;max-width:160px}
.inline-outline.minimal-style .inline-outline-level-1 .inline-outline-text{font-size:11px;font-weight:600}
.inline-outline.minimal-style .inline-outline-level-2 .inline-outline-text{font-weight:500}
.inline-outline.minimal-style:hover .inline-outline-level-1{padding-left:0}
.inline-outline.minimal-style:hover .inline-outline-level-2{padding-left:8px}
.inline-outline.minimal-style:hover .inline-outline-level-3{padding-left:16px}
.inline-outline.minimal-style:hover .inline-outline-level-4{padding-left:24px}
.inline-outline.minimal-style:hover .inline-outline-level-5{padding-left:32px}
.inline-outline.minimal-style:hover .inline-outline-level-6{padding-left:40px}
.inline-outline.minimal-style .inline-outline-empty{font-size:10px}
`;
var MINIMALIST_STYLES = `
/* Hide properties/frontmatter from main editor */
body.minimalist-hide-properties .markdown-source-view .metadata-container,
body.minimalist-hide-properties .markdown-preview-view .metadata-container {
	display: none !important;
}
/* Also hide raw YAML frontmatter in source mode */
body.minimalist-hide-properties .cm-line.HyperMD-frontmatter,
body.minimalist-hide-properties .cm-line.HyperMD-frontmatter-begin,
body.minimalist-hide-properties .cm-line.HyperMD-frontmatter-end {
	display: none !important;
}
/* Keep properties visible in sidebar */
body.minimalist-hide-properties .workspace-leaf-content[data-type="file-properties"] .metadata-container {
	display: block !important;
}
/* Style properties in sidebar */
body.minimalist-hide-properties .workspace-leaf-content[data-type="file-properties"] .metadata-properties-heading {
	font-size: 14px;
	color: var(--text-muted);
	font-weight: 500;
	padding: 8px 0;
}
body.minimalist-hide-properties .workspace-leaf-content[data-type="file-properties"] .collapse-indicator {
	display: none !important;
}
body.minimalist-hide-properties .workspace-leaf-content[data-type="file-properties"] .metadata-property {
	padding: 6px 0;
}
body.minimalist-hide-properties .workspace-leaf-content[data-type="file-properties"] .metadata-property-key {
	font-size: 12px;
	color: var(--text-muted);
	font-weight: 500;
}
body.minimalist-hide-properties .workspace-leaf-content[data-type="file-properties"] .metadata-property-value {
	font-size: 14px;
	color: var(--text-normal);
}

/* Hide scrollbar */
body.minimalist-hide-scrollbar .markdown-source-view ::-webkit-scrollbar,
body.minimalist-hide-scrollbar .markdown-preview-view ::-webkit-scrollbar {
	width: 0 !important;
	height: 0 !important;
}
body.minimalist-hide-scrollbar .cm-scroller {
	scrollbar-width: none;
}
`;
var FOCUS_MODE_STYLES = `
/* Focus Mode - Edit Mode (CodeMirror) */
body.minimalist-focus-mode .markdown-source-view.mod-cm6 .cm-content > .cm-line,
body.minimalist-focus-mode .markdown-source-view.mod-cm6 .cm-content > .cm-embed-block,
body.minimalist-focus-mode .markdown-source-view.mod-cm6 .cm-content > .HyperMD-list-line {
	opacity: var(--focus-dim-opacity, 0.3);
	transition: opacity 0.12s ease-out;
}

/* Active line in edit mode - use Obsidian's native active line detection */
body.minimalist-focus-mode .markdown-source-view.mod-cm6 .cm-content > .cm-active,
body.minimalist-focus-mode .markdown-source-view.mod-cm6 .cm-content > .cm-line.cm-active,
body.minimalist-focus-mode .markdown-source-view.mod-cm6 .cm-content > .cm-focus-active {
	opacity: 1 !important;
}

/* Adjacent lines for smoother transition */
body.minimalist-focus-mode .markdown-source-view.mod-cm6 .cm-content > .cm-focus-adjacent {
	opacity: calc(var(--focus-dim-opacity, 0.3) + 0.3);
}

/* Focus Mode - Reading/Preview Mode */
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > div,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > p,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > h1,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > h2,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > h3,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > h4,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > h5,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > h6,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > ul,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > ol,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > blockquote,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > pre,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > table,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > hr {
	opacity: var(--focus-dim-opacity, 0.3);
	transition: opacity 0.12s ease-out;
}

body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > .focus-active {
	opacity: 1 !important;
}

body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > .focus-adjacent {
	opacity: calc(var(--focus-dim-opacity, 0.3) + 0.3);
}

/* Ensure code blocks and embeds are also handled */
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > .markdown-embed,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > .internal-embed {
	opacity: var(--focus-dim-opacity, 0.3);
	transition: opacity 0.12s ease-out;
}

body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > .markdown-embed.focus-active,
body.minimalist-focus-mode .markdown-preview-view .markdown-preview-sizer > .internal-embed.focus-active {
	opacity: 1 !important;
}
`;
var READING_LINE_OFFSET = 60;
var LINK_REGEX = /\[\[(?:[^\]|]+\|)?([^\]]+)\]\]|\[([^\]]+)\]\([^)]+\)/g;
var InlineOutlinePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.outlineEl = null;
    this.activeIndex = -1;
    this.headings = [];
    this.headingTexts = [];
    this.outlineItems = [];
    this.scrollContainer = null;
    this.isReading = false;
    this.scrollRAF = null;
    this.resizeRAF = null;
    this.focusRAF = null;
    this.sidebarObserver = null;
    this.scrollHandler = null;
    // Focus mode state
    this.focusStyleEl = null;
    this.lastFocusLine = -1;
    this.lastReadingFocusIdx = -1;
    this.focusUpdateDebounced = null;
    this.editorEventCleanup = null;
  }
  async onload() {
    await this.loadSettings();
    const outlineStyle = document.createElement("style");
    outlineStyle.id = "minimalist-outline-styles";
    outlineStyle.textContent = OUTLINE_STYLES;
    document.head.appendChild(outlineStyle);
    this.register(() => outlineStyle.remove());
    const minimalistStyle = document.createElement("style");
    minimalistStyle.id = "minimalist-editor-styles";
    minimalistStyle.textContent = MINIMALIST_STYLES;
    document.head.appendChild(minimalistStyle);
    this.register(() => minimalistStyle.remove());
    this.applyBodyClasses();
    this.updateFocusOpacity();
    if (this.settings.focusMode) {
      this.enableFocusMode();
    }
    this.addSettingTab(new MinimalistSettingTab(this.app, this));
    this.addCommand({ id: "toggle-outline", name: "Toggle Inline Outline", callback: () => this.toggle() });
    this.addCommand({ id: "toggle-focus-mode", name: "Toggle Focus Mode", callback: () => this.toggleFocusMode() });
    const refresh = (0, import_obsidian.debounce)(() => this.refresh(), 300, true);
    this.focusUpdateDebounced = (0, import_obsidian.debounce)(() => this.updateFocusModeImmediate(), 16, true);
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.cleanupEditorEvents();
      setTimeout(() => this.init(), 100);
    }));
    this.registerEvent(this.app.workspace.on("layout-change", () => {
      this.updatePosition();
      setTimeout(() => this.init(), 100);
    }));
    this.registerEvent(this.app.metadataCache.on("changed", refresh));
    this.app.workspace.onLayoutReady(() => {
      this.createOutline();
      this.observeSidebar();
      setTimeout(() => this.init(), 100);
    });
  }
  onunload() {
    var _a, _b, _c;
    this.cleanupEditorEvents();
    if (this.scrollHandler && this.scrollContainer) {
      this.scrollContainer.removeEventListener("scroll", this.scrollHandler);
    }
    (_a = this.outlineEl) == null ? void 0 : _a.remove();
    if (this.scrollRAF)
      cancelAnimationFrame(this.scrollRAF);
    if (this.resizeRAF)
      cancelAnimationFrame(this.resizeRAF);
    if (this.focusRAF)
      cancelAnimationFrame(this.focusRAF);
    (_b = this.sidebarObserver) == null ? void 0 : _b.disconnect();
    this.sidebarObserver = null;
    (_c = this.focusStyleEl) == null ? void 0 : _c.remove();
    this.focusStyleEl = null;
    document.body.classList.remove("minimalist-hide-properties", "minimalist-hide-scrollbar", "minimalist-focus-mode");
    this.clearFocusClasses();
  }
  cleanupEditorEvents() {
    if (this.editorEventCleanup) {
      this.editorEventCleanup();
      this.editorEventCleanup = null;
    }
  }
  init() {
    this.setupScroll();
    this.refresh();
    if (this.settings.focusMode) {
      this.setupFocusModeListeners();
      setTimeout(() => this.updateFocusModeImmediate(), 50);
    }
  }
  toggle() {
    if (this.outlineEl) {
      this.outlineEl.style.display = this.outlineEl.style.display === "none" ? "" : "none";
    }
  }
  toggleFocusMode() {
    this.settings.focusMode = !this.settings.focusMode;
    this.saveSettings();
    if (this.settings.focusMode) {
      this.enableFocusMode();
      this.setupFocusModeListeners();
      this.updateFocusModeImmediate();
    } else {
      this.disableFocusMode();
    }
  }
  enableFocusMode() {
    document.body.classList.add("minimalist-focus-mode");
    if (!this.focusStyleEl) {
      this.focusStyleEl = document.createElement("style");
      this.focusStyleEl.id = "minimalist-focus-styles";
      this.focusStyleEl.textContent = FOCUS_MODE_STYLES;
      document.head.appendChild(this.focusStyleEl);
    }
  }
  disableFocusMode() {
    document.body.classList.remove("minimalist-focus-mode");
    this.clearFocusClasses();
    this.cleanupEditorEvents();
    this.lastFocusLine = -1;
    this.lastReadingFocusIdx = -1;
  }
  createOutline() {
    var _a;
    (_a = this.outlineEl) == null ? void 0 : _a.remove();
    if (!this.settings.showOutline)
      return;
    this.outlineEl = document.createElement("div");
    this.outlineEl.className = "inline-outline" + (this.settings.minimalOutline ? " minimal-style" : "");
    this.outlineEl.id = "inline-outline";
    document.body.appendChild(this.outlineEl);
  }
  applyBodyClasses() {
    document.body.classList.toggle("minimalist-hide-properties", this.settings.hideProperties);
    document.body.classList.toggle("minimalist-hide-scrollbar", this.settings.hideScrollbar);
    document.body.classList.toggle("minimalist-focus-mode", this.settings.focusMode);
  }
  updateFocusOpacity() {
    document.documentElement.style.setProperty("--focus-dim-opacity", String(this.settings.focusDimOpacity / 100));
  }
  updateOutlineStyle() {
    var _a;
    (_a = this.outlineEl) == null ? void 0 : _a.classList.toggle("minimal-style", this.settings.minimalOutline);
  }
  toggleOutlineVisibility() {
    var _a;
    if (this.settings.showOutline) {
      if (!this.outlineEl) {
        this.createOutline();
        this.refresh();
      }
    } else {
      (_a = this.outlineEl) == null ? void 0 : _a.remove();
      this.outlineEl = null;
    }
  }
  setupScroll() {
    var _a;
    if (this.scrollHandler && this.scrollContainer) {
      this.scrollContainer.removeEventListener("scroll", this.scrollHandler);
    }
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view) {
      this.scrollContainer = null;
      this.scrollHandler = null;
      return;
    }
    this.isReading = view.getMode() === "preview";
    const selector = this.isReading ? ".markdown-preview-view" : ".cm-scroller";
    this.scrollContainer = view.contentEl.querySelector(selector);
    this.scrollHandler = () => {
      if (this.scrollRAF)
        return;
      this.scrollRAF = requestAnimationFrame(() => {
        var _a2;
        this.scrollRAF = null;
        this.updateActive();
        if (this.settings.focusMode && this.isReading) {
          (_a2 = this.focusUpdateDebounced) == null ? void 0 : _a2.call(this);
        }
      });
    };
    (_a = this.scrollContainer) == null ? void 0 : _a.addEventListener("scroll", this.scrollHandler, { passive: true });
  }
  setupFocusModeListeners() {
    if (!this.settings.focusMode)
      return;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return;
    this.cleanupEditorEvents();
    if (!this.isReading) {
      const editor = view.editor;
      const cm = editor == null ? void 0 : editor.cm;
      if (cm) {
        const contentDOM = cm.contentDOM;
        const selectionHandler = () => {
          if (this.focusRAF)
            return;
          this.focusRAF = requestAnimationFrame(() => {
            this.focusRAF = null;
            this.updateEditModeFocus(view);
          });
        };
        document.addEventListener("selectionchange", selectionHandler);
        const keyHandler = () => {
          if (this.focusRAF)
            return;
          this.focusRAF = requestAnimationFrame(() => {
            this.focusRAF = null;
            this.updateEditModeFocus(view);
          });
        };
        contentDOM.addEventListener("keyup", keyHandler, { passive: true });
        contentDOM.addEventListener("click", keyHandler, { passive: true });
        this.editorEventCleanup = () => {
          document.removeEventListener("selectionchange", selectionHandler);
          contentDOM.removeEventListener("keyup", keyHandler);
          contentDOM.removeEventListener("click", keyHandler);
        };
      }
    }
  }
  observeSidebar() {
    const sidebar = document.querySelector(".mod-right-split");
    if (!sidebar)
      return;
    this.sidebarObserver = new ResizeObserver(() => {
      if (this.resizeRAF)
        return;
      this.resizeRAF = requestAnimationFrame(() => {
        this.resizeRAF = null;
        this.updatePosition();
      });
    });
    this.sidebarObserver.observe(sidebar);
  }
  updatePosition() {
    if (!this.outlineEl)
      return;
    const sidebar = document.querySelector(".mod-right-split");
    const width = (sidebar == null ? void 0 : sidebar.getBoundingClientRect().width) || 0;
    this.outlineEl.style.right = `${width > 0 ? width + 24 : 24}px`;
  }
  refresh() {
    var _a;
    const file = this.app.workspace.getActiveFile();
    const cache = file && this.app.metadataCache.getFileCache(file);
    this.headings = ((_a = cache == null ? void 0 : cache.headings) == null ? void 0 : _a.map((h) => ({
      level: h.level,
      text: h.heading,
      position: h.position
    }))) || [];
    this.headingTexts = this.headings.map((h) => this.strip(h.text).toLowerCase());
    this.render();
    this.activeIndex = -1;
    if (this.isReading) {
      setTimeout(() => this.updateActive(), 150);
    } else {
      this.updateActive();
    }
  }
  strip(text) {
    return text.replace(LINK_REGEX, "$1$2").trim();
  }
  render() {
    if (!this.outlineEl)
      return;
    this.outlineEl.empty();
    this.outlineItems = [];
    if (!this.headings.length) {
      const empty = document.createElement("div");
      empty.className = "inline-outline-empty";
      empty.textContent = "No headings";
      this.outlineEl.appendChild(empty);
      return;
    }
    const frag = document.createDocumentFragment();
    this.headings.forEach((h, i) => {
      const item = document.createElement("div");
      item.className = `inline-outline-item inline-outline-level-${h.level}`;
      const line = document.createElement("div");
      line.className = "inline-outline-line";
      const text = document.createElement("span");
      text.className = "inline-outline-text";
      text.textContent = this.strip(h.text);
      item.appendChild(line);
      item.appendChild(text);
      item.addEventListener("click", () => this.navigate(i));
      frag.appendChild(item);
      this.outlineItems.push(item);
    });
    this.outlineEl.appendChild(frag);
  }
  updateActive() {
    var _a;
    if (!this.outlineEl || !this.headings.length || !this.scrollContainer)
      return;
    const rect = this.scrollContainer.getBoundingClientRect();
    const readingLine = rect.top + READING_LINE_OFFSET + 20;
    let active = 0;
    if (this.isReading) {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      const preview = view == null ? void 0 : view.contentEl.querySelector(".markdown-preview-view");
      if (!preview)
        return;
      const els = Array.from(preview.querySelectorAll("h1,h2,h3,h4,h5,h6"));
      let lastAbove = 0;
      for (const el of els) {
        const top = el.getBoundingClientRect().top;
        const text = (el.textContent || "").toLowerCase().trim();
        let idx = this.headingTexts.indexOf(text);
        if (idx === -1) {
          idx = this.headingTexts.findIndex((t) => text.includes(t) || t.includes(text));
        }
        if (idx === -1)
          continue;
        if (top <= readingLine)
          lastAbove = idx;
        if (top >= readingLine - 20) {
          active = idx;
          break;
        }
      }
      if (active === 0 && lastAbove > 0)
        active = lastAbove;
    } else {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      const cm = (_a = view == null ? void 0 : view.editor) == null ? void 0 : _a.cm;
      if (!(cm == null ? void 0 : cm.coordsAtPos))
        return;
      let lastAbove = 0;
      for (let i = 0; i < this.headings.length; i++) {
        try {
          const line = this.headings[i].position.start.line;
          const coords = cm.coordsAtPos(cm.state.doc.line(line + 1).from, -1);
          if (!coords)
            continue;
          if (coords.top <= readingLine)
            lastAbove = i;
          if (coords.top >= readingLine - 20) {
            active = i;
            break;
          }
        } catch (e) {
          continue;
        }
      }
      if (active === 0 && lastAbove > 0)
        active = lastAbove;
    }
    if (active !== this.activeIndex) {
      this.activeIndex = active;
      this.outlineItems.forEach((el, i) => el.classList.toggle("active", i === active));
    }
  }
  navigate(index) {
    const h = this.headings[index];
    if (!h)
      return;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return;
    this.activeIndex = index;
    this.outlineItems.forEach((el, i) => el.classList.toggle("active", i === index));
    const file = this.app.workspace.getActiveFile();
    if (file) {
      this.app.workspace.openLinkText(
        file.path + "#" + h.text,
        file.path,
        false
      );
    }
  }
  // Focus Mode methods
  updateFocusModeImmediate() {
    if (!this.settings.focusMode)
      return;
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!view)
      return;
    if (this.isReading) {
      this.updateReadingModeFocus(view);
    } else {
      this.updateEditModeFocus(view);
    }
  }
  updateEditModeFocus(view) {
    const editor = view.editor;
    const cm = editor == null ? void 0 : editor.cm;
    if (!cm)
      return;
    const cursor = view.editor.getCursor();
    const currentLine = cursor.line;
    if (currentLine === this.lastFocusLine)
      return;
    this.lastFocusLine = currentLine;
    const contentDOM = cm.contentDOM;
    if (!contentDOM)
      return;
    const lineElements = contentDOM.querySelectorAll(":scope > .cm-line, :scope > .cm-embed-block");
    if (!lineElements.length)
      return;
    lineElements.forEach((el) => {
      el.classList.remove("cm-focus-active", "cm-focus-adjacent");
    });
    try {
      const cursorPos = cm.state.doc.line(currentLine + 1).from;
      const cursorCoords = cm.coordsAtPos(cursorPos, -1);
      if (!cursorCoords) {
        const visibleRanges = cm.visibleRanges;
        if (visibleRanges.length > 0 && lineElements.length > 0) {
          if (cursorPos <= visibleRanges[0].from || currentLine === 0) {
            lineElements[0].classList.add("cm-focus-active");
            if (lineElements.length > 1) {
              lineElements[1].classList.add("cm-focus-adjacent");
            }
          }
        }
        return;
      }
      const scroller = view.contentEl.querySelector(".cm-scroller");
      const scrollerRect = scroller == null ? void 0 : scroller.getBoundingClientRect();
      if (!scrollerRect)
        return;
      const cursorRelTop = cursorCoords.top - scrollerRect.top;
      let activeIdx = -1;
      let minDist = Infinity;
      lineElements.forEach((el, idx) => {
        const rect = el.getBoundingClientRect();
        const elRelTop = rect.top - scrollerRect.top;
        const dist = Math.abs(elRelTop - cursorRelTop);
        if (dist < minDist) {
          minDist = dist;
          activeIdx = idx;
        }
      });
      if (activeIdx >= 0) {
        lineElements[activeIdx].classList.add("cm-focus-active");
        if (activeIdx > 0) {
          lineElements[activeIdx - 1].classList.add("cm-focus-adjacent");
        }
        if (activeIdx < lineElements.length - 1) {
          lineElements[activeIdx + 1].classList.add("cm-focus-adjacent");
        }
      } else if (currentLine === 0 && lineElements.length > 0) {
        lineElements[0].classList.add("cm-focus-active");
        if (lineElements.length > 1) {
          lineElements[1].classList.add("cm-focus-adjacent");
        }
      }
    } catch (e) {
      if (currentLine === 0 && lineElements.length > 0) {
        lineElements[0].classList.add("cm-focus-active");
        if (lineElements.length > 1) {
          lineElements[1].classList.add("cm-focus-adjacent");
        }
      }
    }
  }
  updateReadingModeFocus(view) {
    const preview = view.contentEl.querySelector(".markdown-preview-view");
    const sizer = preview == null ? void 0 : preview.querySelector(".markdown-preview-sizer");
    if (!sizer || !preview)
      return;
    const selector = ":scope > div, :scope > p, :scope > h1, :scope > h2, :scope > h3, :scope > h4, :scope > h5, :scope > h6, :scope > ul, :scope > ol, :scope > blockquote, :scope > pre, :scope > table, :scope > hr, :scope > .markdown-embed, :scope > .internal-embed";
    const children = Array.from(sizer.querySelectorAll(selector));
    if (!children.length)
      return;
    const previewRect = preview.getBoundingClientRect();
    const viewportTop = previewRect.top;
    const viewportBottom = previewRect.bottom;
    const focusLine = viewportTop + Math.min(150, (viewportBottom - viewportTop) * 0.25);
    let activeIdx = 0;
    let lastAboveIdx = -1;
    let firstVisibleIdx = -1;
    for (let idx = 0; idx < children.length; idx++) {
      const child = children[idx];
      const rect = child.getBoundingClientRect();
      if (rect.height === 0)
        continue;
      const elementTop = rect.top;
      const elementBottom = rect.bottom;
      if (firstVisibleIdx === -1 && elementBottom > viewportTop && elementTop < viewportBottom) {
        firstVisibleIdx = idx;
      }
      if (elementTop <= focusLine) {
        lastAboveIdx = idx;
      }
      if (elementTop <= focusLine && elementBottom >= focusLine) {
        activeIdx = idx;
        break;
      }
      if (elementTop > focusLine) {
        activeIdx = lastAboveIdx >= 0 ? lastAboveIdx : idx;
        break;
      }
      if (idx === children.length - 1) {
        activeIdx = lastAboveIdx >= 0 ? lastAboveIdx : 0;
      }
    }
    if (activeIdx === 0 && lastAboveIdx === -1 && firstVisibleIdx >= 0) {
      activeIdx = firstVisibleIdx;
    }
    if (preview.scrollTop <= 10 && children.length > 0) {
      activeIdx = 0;
    }
    if (activeIdx === this.lastReadingFocusIdx)
      return;
    this.lastReadingFocusIdx = activeIdx;
    children.forEach((child, idx) => {
      child.classList.remove("focus-active", "focus-adjacent");
      if (idx === activeIdx) {
        child.classList.add("focus-active");
      } else if (Math.abs(idx - activeIdx) === 1) {
        child.classList.add("focus-adjacent");
      }
    });
  }
  clearFocusClasses() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (view) {
      const contentEl = view.contentEl;
      contentEl.querySelectorAll(".cm-focus-active, .cm-focus-adjacent").forEach((el) => {
        el.classList.remove("cm-focus-active", "cm-focus-adjacent");
      });
      contentEl.querySelectorAll(".focus-active, .focus-adjacent").forEach((el) => {
        el.classList.remove("focus-active", "focus-adjacent");
      });
    }
    document.querySelectorAll(".cm-focus-active, .cm-focus-adjacent, .focus-active, .focus-adjacent").forEach((el) => {
      el.classList.remove("cm-focus-active", "cm-focus-adjacent", "focus-active", "focus-adjacent");
    });
    this.lastFocusLine = -1;
    this.lastReadingFocusIdx = -1;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var MinimalistSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    this.containerEl.empty();
    this.containerEl.createEl("h2", { text: "The Minimalist Editor" });
    this.containerEl.createEl("h3", { text: "Inline Outline" });
    new import_obsidian.Setting(this.containerEl).setName("Show Outline").setDesc("Display the inline outline on the right side of the editor").addToggle((t) => t.setValue(this.plugin.settings.showOutline).onChange(async (v) => {
      this.plugin.settings.showOutline = v;
      await this.plugin.saveSettings();
      this.plugin.toggleOutlineVisibility();
    }));
    new import_obsidian.Setting(this.containerEl).setName("Minimal Style").setDesc("Notion-like: positioned higher, smaller lines and text").addToggle((t) => t.setValue(this.plugin.settings.minimalOutline).onChange(async (v) => {
      this.plugin.settings.minimalOutline = v;
      await this.plugin.saveSettings();
      this.plugin.updateOutlineStyle();
    }));
    this.containerEl.createEl("h3", { text: "Distraction-free" });
    new import_obsidian.Setting(this.containerEl).setName("Hide Properties").setDesc("Hide the properties/metadata panel from the editor (still visible in sidebar)").addToggle((t) => t.setValue(this.plugin.settings.hideProperties).onChange(async (v) => {
      this.plugin.settings.hideProperties = v;
      await this.plugin.saveSettings();
      this.plugin.applyBodyClasses();
    }));
    new import_obsidian.Setting(this.containerEl).setName("Hide Scrollbar").setDesc("Hide the scrollbar for a cleaner appearance").addToggle((t) => t.setValue(this.plugin.settings.hideScrollbar).onChange(async (v) => {
      this.plugin.settings.hideScrollbar = v;
      await this.plugin.saveSettings();
      this.plugin.applyBodyClasses();
    }));
    this.containerEl.createEl("h3", { text: "Focus Mode" });
    new import_obsidian.Setting(this.containerEl).setName("Enable Focus Mode").setDesc("Dim content except the current line/paragraph for distraction-free writing").addToggle((t) => t.setValue(this.plugin.settings.focusMode).onChange(async (v) => {
      this.plugin.settings.focusMode = v;
      await this.plugin.saveSettings();
      if (v) {
        this.plugin.applyBodyClasses();
        const view = this.plugin.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view) {
          setTimeout(() => {
            this.plugin["enableFocusMode"]();
            this.plugin["setupFocusModeListeners"]();
            this.plugin["updateFocusModeImmediate"]();
          }, 50);
        }
      } else {
        this.plugin["disableFocusMode"]();
      }
    }));
    new import_obsidian.Setting(this.containerEl).setName("Dim Opacity").setDesc("How much to dim unfocused content (lower = more dim)").addSlider((s) => s.setLimits(10, 70, 5).setValue(this.plugin.settings.focusDimOpacity).setDynamicTooltip().onChange(async (v) => {
      this.plugin.settings.focusDimOpacity = v;
      await this.plugin.saveSettings();
      this.plugin.updateFocusOpacity();
    }));
  }
};
