/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => InlineOutlinePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/settings.ts
var DEFAULT_SETTINGS = {
  showOutline: true,
  minimalOutline: false,
  hideProperties: true,
  hideScrollbar: false,
  focusMode: false,
  focusDimOpacity: 30
};

// src/main.ts
var LINK_REGEX = /\[\[(?:[^\]|]+\|)?([^\]]+)\]\]|\[([^\]]+)\]\([^)]+\)/g;
var FOCUS_CLASSES = ["cm-focus-active", "cm-focus-adjacent", "focus-active", "focus-adjacent"];
var InlineOutlinePlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.outlineEl = null;
    this.outlineItems = [];
    this.headings = [];
    this.headingTexts = [];
    this.scrollContainer = null;
    this.activeIndex = -1;
    this.isReading = false;
    this.lastFocusLine = -1;
    this.lastFocusIdx = -1;
    this.scrollRAF = null;
    this.resizeRAF = null;
    this.focusRAF = null;
    this.sidebarObserver = null;
    this.cleanupFns = [];
  }
  async onload() {
    await this.loadSettings();
    this.applyBodyClasses();
    this.updateFocusOpacity();
    this.addSettingTab(new MinimalistSettingTab(this.app, this));
    this.addCommand({ id: "toggle-outline", name: "Toggle inline outline", callback: () => this.toggleOutline() });
    this.addCommand({ id: "toggle-focus-mode", name: "Toggle focus mode", callback: () => this.toggleFocusMode() });
    const refresh = (0, import_obsidian.debounce)(() => this.refresh(), 300, true);
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => {
      this.cleanup();
      setTimeout(() => this.init(), 100);
    }));
    this.registerEvent(this.app.workspace.on("layout-change", () => {
      this.updatePosition();
      setTimeout(() => this.init(), 100);
    }));
    this.registerEvent(this.app.metadataCache.on("changed", refresh));
    this.app.workspace.onLayoutReady(() => {
      this.createOutline();
      this.observeSidebar();
      setTimeout(() => this.init(), 100);
    });
  }
  onunload() {
    var _a, _b;
    this.cleanup();
    (_a = this.outlineEl) == null ? void 0 : _a.remove();
    [this.scrollRAF, this.resizeRAF, this.focusRAF].forEach((r) => r && cancelAnimationFrame(r));
    (_b = this.sidebarObserver) == null ? void 0 : _b.disconnect();
    document.body.classList.remove("minimalist-hide-properties", "minimalist-hide-scrollbar", "minimalist-focus-mode");
    this.clearFocusClasses();
  }
  cleanup() {
    this.cleanupFns.forEach((fn) => fn());
    this.cleanupFns = [];
  }
  init() {
    var _a;
    const view = this.getView();
    if (!view) {
      this.scrollContainer = null;
      return;
    }
    this.isReading = view.getMode() === "preview";
    this.scrollContainer = view.contentEl.querySelector(this.isReading ? ".markdown-preview-view" : ".cm-scroller");
    const onScroll = () => this.scheduleRAF("scrollRAF", () => {
      this.updateActive();
      if (this.settings.focusMode && this.isReading)
        this.updateFocus();
    });
    (_a = this.scrollContainer) == null ? void 0 : _a.addEventListener("scroll", onScroll, { passive: true });
    this.cleanupFns.push(() => {
      var _a2;
      return (_a2 = this.scrollContainer) == null ? void 0 : _a2.removeEventListener("scroll", onScroll);
    });
    if (this.settings.focusMode && !this.isReading) {
      const cm = this.getCM(view);
      if (cm) {
        const onCursor = () => this.scheduleRAF("focusRAF", () => this.updateFocus());
        document.addEventListener("selectionchange", onCursor);
        cm.contentDOM.addEventListener("keyup", onCursor, { passive: true });
        cm.contentDOM.addEventListener("click", onCursor, { passive: true });
        this.cleanupFns.push(() => {
          document.removeEventListener("selectionchange", onCursor);
          cm.contentDOM.removeEventListener("keyup", onCursor);
          cm.contentDOM.removeEventListener("click", onCursor);
        });
      }
    }
    this.refresh();
    if (this.settings.focusMode)
      setTimeout(() => this.updateFocus(), 50);
  }
  scheduleRAF(key, fn) {
    if (this[key])
      return;
    this[key] = requestAnimationFrame(() => {
      this[key] = null;
      fn();
    });
  }
  getView() {
    return this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
  }
  getCM(view) {
    var _a, _b;
    return (_b = (_a = view.editor) == null ? void 0 : _a.cm) != null ? _b : null;
  }
  toggleOutline() {
    if (this.outlineEl)
      this.outlineEl.style.display = this.outlineEl.style.display === "none" ? "" : "none";
  }
  toggleFocusMode() {
    this.settings.focusMode = !this.settings.focusMode;
    void this.saveSettings();
    this.applyBodyClasses();
    if (this.settings.focusMode) {
      this.cleanup();
      this.init();
    } else {
      this.clearFocusClasses();
      this.lastFocusLine = this.lastFocusIdx = -1;
    }
  }
  createOutline() {
    var _a;
    (_a = this.outlineEl) == null ? void 0 : _a.remove();
    if (!this.settings.showOutline)
      return;
    this.outlineEl = document.body.createDiv({
      cls: "inline-outline" + (this.settings.minimalOutline ? " minimal-style" : ""),
      attr: { id: "inline-outline" }
    });
  }
  applyBodyClasses() {
    const { classList } = document.body;
    classList.toggle("minimalist-hide-properties", this.settings.hideProperties);
    classList.toggle("minimalist-hide-scrollbar", this.settings.hideScrollbar);
    classList.toggle("minimalist-focus-mode", this.settings.focusMode);
  }
  updateFocusOpacity() {
    document.documentElement.style.setProperty("--focus-dim-opacity", String(this.settings.focusDimOpacity / 100));
  }
  updateOutlineStyle() {
    var _a;
    (_a = this.outlineEl) == null ? void 0 : _a.classList.toggle("minimal-style", this.settings.minimalOutline);
  }
  toggleOutlineVisibility() {
    var _a;
    if (this.settings.showOutline) {
      if (!this.outlineEl) {
        this.createOutline();
        this.refresh();
      }
    } else {
      (_a = this.outlineEl) == null ? void 0 : _a.remove();
      this.outlineEl = null;
    }
  }
  observeSidebar() {
    const sidebar = document.querySelector(".mod-right-split");
    if (!sidebar)
      return;
    this.sidebarObserver = new ResizeObserver(() => this.scheduleRAF("resizeRAF", () => this.updatePosition()));
    this.sidebarObserver.observe(sidebar);
  }
  updatePosition() {
    var _a;
    if (!this.outlineEl)
      return;
    const w = ((_a = document.querySelector(".mod-right-split")) == null ? void 0 : _a.getBoundingClientRect().width) || 0;
    this.outlineEl.style.right = `${w > 0 ? w + 24 : 24}px`;
  }
  refresh() {
    var _a;
    const file = this.app.workspace.getActiveFile();
    const cache = file && this.app.metadataCache.getFileCache(file);
    this.headings = ((_a = cache == null ? void 0 : cache.headings) == null ? void 0 : _a.map((h) => ({ level: h.level, text: h.heading, position: h.position }))) || [];
    this.headingTexts = this.headings.map((h) => this.strip(h.text).toLowerCase());
    this.render();
    this.activeIndex = -1;
    if (this.isReading) {
      setTimeout(() => this.updateActive(), 150);
    } else {
      this.updateActive();
    }
  }
  strip(text) {
    return text.replace(LINK_REGEX, "$1$2").trim();
  }
  render() {
    if (!this.outlineEl)
      return;
    this.outlineEl.empty();
    this.outlineItems = [];
    if (!this.headings.length) {
      this.outlineEl.createDiv({ cls: "inline-outline-empty", text: "No headings" });
      return;
    }
    const frag = document.createDocumentFragment();
    this.headings.forEach((h, i) => {
      const item = frag.createDiv({ cls: `inline-outline-item inline-outline-level-${h.level}` });
      item.createDiv({ cls: "inline-outline-line" });
      item.createSpan({ cls: "inline-outline-text", text: this.strip(h.text) });
      item.addEventListener("click", () => this.navigate(i));
      this.outlineItems.push(item);
    });
    this.outlineEl.appendChild(frag);
  }
  updateActive() {
    var _a;
    if (!this.outlineEl || !this.headings.length || !this.scrollContainer)
      return;
    const rect = this.scrollContainer.getBoundingClientRect();
    const readingLine = rect.top + 80;
    let active = 0, lastAbove = 0;
    if (this.isReading) {
      const view = this.getView();
      const els = Array.from((_a = view == null ? void 0 : view.contentEl.querySelectorAll(".markdown-preview-view h1,h2,h3,h4,h5,h6")) != null ? _a : []);
      if (!els.length)
        return;
      for (const el of els) {
        const top = el.getBoundingClientRect().top;
        const text = (el.textContent || "").toLowerCase().trim();
        let idx = this.headingTexts.indexOf(text);
        if (idx === -1)
          idx = this.headingTexts.findIndex((t) => text.includes(t) || t.includes(text));
        if (idx === -1)
          continue;
        if (top <= readingLine)
          lastAbove = idx;
        if (top >= readingLine - 20) {
          active = idx;
          break;
        }
      }
    } else {
      const view = this.getView();
      const cm = view && this.getCM(view);
      if (!cm)
        return;
      for (let i = 0; i < this.headings.length; i++) {
        try {
          const coords = cm.coordsAtPos(cm.state.doc.line(this.headings[i].position.start.line + 1).from, -1);
          if (!coords)
            continue;
          if (coords.top <= readingLine)
            lastAbove = i;
          if (coords.top >= readingLine - 20) {
            active = i;
            break;
          }
        } catch (e) {
          continue;
        }
      }
    }
    if (active === 0 && lastAbove > 0)
      active = lastAbove;
    if (active !== this.activeIndex) {
      this.activeIndex = active;
      this.outlineItems.forEach((el, i) => el.classList.toggle("active", i === active));
    }
  }
  navigate(index) {
    const h = this.headings[index];
    if (!h || !this.getView())
      return;
    this.activeIndex = index;
    this.outlineItems.forEach((el, i) => el.classList.toggle("active", i === index));
    const file = this.app.workspace.getActiveFile();
    if (file)
      void this.app.workspace.openLinkText(`${file.path}#${h.text}`, file.path, false);
  }
  updateFocus() {
    if (!this.settings.focusMode)
      return;
    const view = this.getView();
    if (!view)
      return;
    if (this.isReading) {
      this.updateReadingFocus(view);
    } else {
      this.updateEditFocus(view);
    }
  }
  updateEditFocus(view) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const cm = this.getCM(view);
    if (!cm)
      return;
    const line = view.editor.getCursor().line;
    if (line === this.lastFocusLine)
      return;
    this.lastFocusLine = line;
    const lines = cm.contentDOM.querySelectorAll(":scope > .cm-line, :scope > .cm-embed-block");
    if (!lines.length)
      return;
    lines.forEach((el) => el.classList.remove("cm-focus-active", "cm-focus-adjacent"));
    try {
      const pos = cm.state.doc.line(line + 1).from;
      const coords = cm.coordsAtPos(pos, -1);
      if (!coords) {
        if (line === 0 || cm.visibleRanges[0] && pos <= cm.visibleRanges[0].from) {
          (_a = lines[0]) == null ? void 0 : _a.classList.add("cm-focus-active");
          (_b = lines[1]) == null ? void 0 : _b.classList.add("cm-focus-adjacent");
        }
        return;
      }
      const scroller = view.contentEl.querySelector(".cm-scroller");
      const scrollerTop = (_c = scroller == null ? void 0 : scroller.getBoundingClientRect().top) != null ? _c : 0;
      const cursorRel = coords.top - scrollerTop;
      let activeIdx = -1, minDist = Infinity;
      lines.forEach((el, idx) => {
        const dist = Math.abs(el.getBoundingClientRect().top - scrollerTop - cursorRel);
        if (dist < minDist) {
          minDist = dist;
          activeIdx = idx;
        }
      });
      if (activeIdx >= 0) {
        lines[activeIdx].classList.add("cm-focus-active");
        (_d = lines[activeIdx - 1]) == null ? void 0 : _d.classList.add("cm-focus-adjacent");
        (_e = lines[activeIdx + 1]) == null ? void 0 : _e.classList.add("cm-focus-adjacent");
      } else if (line === 0) {
        (_f = lines[0]) == null ? void 0 : _f.classList.add("cm-focus-active");
        (_g = lines[1]) == null ? void 0 : _g.classList.add("cm-focus-adjacent");
      }
    } catch (e) {
      if (line === 0) {
        (_h = lines[0]) == null ? void 0 : _h.classList.add("cm-focus-active");
        (_i = lines[1]) == null ? void 0 : _i.classList.add("cm-focus-adjacent");
      }
    }
  }
  updateReadingFocus(view) {
    const preview = view.contentEl.querySelector(".markdown-preview-view");
    const sizer = preview == null ? void 0 : preview.querySelector(".markdown-preview-sizer");
    if (!sizer || !preview)
      return;
    const children = Array.from(sizer.children).filter((c) => c.offsetHeight > 0);
    if (!children.length)
      return;
    const { top: vTop, bottom: vBottom } = preview.getBoundingClientRect();
    const focusLine = vTop + Math.min(150, (vBottom - vTop) * 0.25);
    let activeIdx = 0, lastAbove = -1, firstVisible = -1;
    for (let i = 0; i < children.length; i++) {
      const { top, bottom } = children[i].getBoundingClientRect();
      if (firstVisible === -1 && bottom > vTop && top < vBottom)
        firstVisible = i;
      if (top <= focusLine)
        lastAbove = i;
      if (top <= focusLine && bottom >= focusLine) {
        activeIdx = i;
        break;
      }
      if (top > focusLine) {
        activeIdx = lastAbove >= 0 ? lastAbove : i;
        break;
      }
      if (i === children.length - 1)
        activeIdx = lastAbove >= 0 ? lastAbove : 0;
    }
    if (activeIdx === 0 && lastAbove === -1 && firstVisible >= 0)
      activeIdx = firstVisible;
    if (preview.scrollTop <= 10)
      activeIdx = 0;
    if (activeIdx === this.lastFocusIdx)
      return;
    this.lastFocusIdx = activeIdx;
    children.forEach((c, i) => {
      c.classList.remove("focus-active", "focus-adjacent");
      if (i === activeIdx)
        c.classList.add("focus-active");
      else if (Math.abs(i - activeIdx) === 1)
        c.classList.add("focus-adjacent");
    });
  }
  clearFocusClasses() {
    document.querySelectorAll(FOCUS_CLASSES.map((c) => `.${c}`).join(",")).forEach(
      (el) => FOCUS_CLASSES.forEach((c) => el.classList.remove(c))
    );
    this.lastFocusLine = this.lastFocusIdx = -1;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var MinimalistSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const sections = [
      ["Inline outline", [
        ["Show outline", "Display the inline outline on the right side", "showOutline", () => this.plugin.toggleOutlineVisibility()],
        ["Minimal style", "Notion-like: positioned higher, smaller elements", "minimalOutline", () => this.plugin.updateOutlineStyle()]
      ]],
      ["Distraction-free", [
        ["Hide properties", "Hide properties/metadata from editor (visible in sidebar)", "hideProperties", () => this.plugin.applyBodyClasses()],
        ["Hide scrollbar", "Hide scrollbar for cleaner appearance", "hideScrollbar", () => this.plugin.applyBodyClasses()]
      ]],
      ["Focus mode", [
        ["Enable focus mode", "Dim content except current line/paragraph", "focusMode", () => {
          this.plugin.applyBodyClasses();
          if (this.plugin.settings.focusMode) {
            this.plugin["cleanup"]();
            this.plugin["init"]();
          } else {
            this.plugin["clearFocusClasses"]();
          }
        }]
      ]]
    ];
    for (const [title, settings] of sections) {
      new import_obsidian.Setting(containerEl).setName(title).setHeading();
      for (const [name, desc, key, onChange] of settings) {
        new import_obsidian.Setting(containerEl).setName(name).setDesc(desc).addToggle(
          (t) => t.setValue(this.plugin.settings[key]).onChange(async (v) => {
            this.plugin.settings[key] = v;
            await this.plugin.saveSettings();
            onChange();
          })
        );
      }
    }
    new import_obsidian.Setting(containerEl).setName("Dim opacity").setDesc("How much to dim unfocused content (lower = more dim)").addSlider((s) => s.setLimits(10, 70, 5).setValue(this.plugin.settings.focusDimOpacity).setDynamicTooltip().onChange(async (v) => {
      this.plugin.settings.focusDimOpacity = v;
      await this.plugin.saveSettings();
      this.plugin.updateFocusOpacity();
    }));
  }
};
